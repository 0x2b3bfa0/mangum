{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mangum Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Features API Gateway support for HTTP , REST , and WebSocket APIs. Multiple storage backend interfaces for managing WebSocket connections. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events. Requirements Python 3.6+ Installation pip install mangum Example from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app ) or using a framework: from mangum import Mangum from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route async def homepage ( request ): response = PlainTextResponse ( \"Hello, world!\" ) return response app = Starlette ( debug = True , routes = [ Route ( \"/\" , homepage )]) handler = Mangum ( app )","title":"Introduction"},{"location":"#mangum","text":"Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses.","title":"Mangum"},{"location":"#features","text":"API Gateway support for HTTP , REST , and WebSocket APIs. Multiple storage backend interfaces for managing WebSocket connections. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events.","title":"Features"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"pip install mangum","title":"Installation"},{"location":"#example","text":"from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app ) or using a framework: from mangum import Mangum from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.routing import Route async def homepage ( request ): response = PlainTextResponse ( \"Hello, world!\" ) return response app = Starlette ( debug = True , routes = [ Route ( \"/\" , homepage )]) handler = Mangum ( app )","title":"Example"},{"location":"adapter/","text":"Adapter The heart of Mangum is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in an AWS Lambda deployment. The adapter accepts a number of keyword arguments to configure settings related to logging, HTTP & WebSocket events, lifespan behaviour, and API Gateway. handler = Mangum ( app , lifespan = \"auto\" , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None ) All arguments are optional, but some may be necessary for specific use-cases (e.g. dsn is only required for WebSocket support). Configuring an adapter instance class mangum.adapter. Mangum ( app , lifespan='auto' , log_level='info' , api_gateway_base_path=None , text_mime_types=None , dsn=None , api_gateway_endpoint_url=None , api_gateway_region_name=None , enable_lifespan=True ) Creates an adapter instance. Parameters: app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . log_level - A string to configure the log level. Choices are: info , critical , error , warning , and debug . Default is info . api_gateway_base_path - Base path to strip from URL when using a custom domain name. text_mime_types - A list of MIME types to include with the defaults that should not return a binary response in API Gateway. dsn - A connection string required to configure a supported WebSocket backend. api_gateway_endpoint_url - A string endpoint url to use for API Gateway when sending data to WebSocket connections. Default is None . api_gateway_region_name - A string region name to use for API Gateway when sending data to WebSocket connections. Default is AWS_REGION environment variable. Creating an AWS Lambda handler The adapter can be used to wrap any application without referencing the underlying methods. It defines a __call__ method that allows the class instance to be used as an AWS Lambda event handler function. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The handler in the example above could be replaced with a function. def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. return asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response Retrieving the AWS event and context The AWS Lambda handler event and context arguments are made available to an ASGI application in the ASGI connection scope. scope [ 'aws.event' ] scope [ 'aws.context' ] If you're using FastAPI it can be retrieved from the scope attribute of the request object. from fastapi import FastAPI from mangum import Mangum from starlette.requests import Request app = FastAPI () @app . get ( \"/\" ) def hello ( request : Request ): return { \"aws_event\" : request . scope [ \"aws.event\" ]} handler = Mangum ( app )","title":"Adapter"},{"location":"adapter/#adapter","text":"The heart of Mangum is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in an AWS Lambda deployment. The adapter accepts a number of keyword arguments to configure settings related to logging, HTTP & WebSocket events, lifespan behaviour, and API Gateway. handler = Mangum ( app , lifespan = \"auto\" , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None ) All arguments are optional, but some may be necessary for specific use-cases (e.g. dsn is only required for WebSocket support).","title":"Adapter"},{"location":"adapter/#configuring-an-adapter-instance","text":"class mangum.adapter. Mangum ( app , lifespan='auto' , log_level='info' , api_gateway_base_path=None , text_mime_types=None , dsn=None , api_gateway_endpoint_url=None , api_gateway_region_name=None , enable_lifespan=True ) Creates an adapter instance. Parameters: app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . log_level - A string to configure the log level. Choices are: info , critical , error , warning , and debug . Default is info . api_gateway_base_path - Base path to strip from URL when using a custom domain name. text_mime_types - A list of MIME types to include with the defaults that should not return a binary response in API Gateway. dsn - A connection string required to configure a supported WebSocket backend. api_gateway_endpoint_url - A string endpoint url to use for API Gateway when sending data to WebSocket connections. Default is None . api_gateway_region_name - A string region name to use for API Gateway when sending data to WebSocket connections. Default is AWS_REGION environment variable.","title":"Configuring an adapter instance"},{"location":"adapter/#creating-an-aws-lambda-handler","text":"The adapter can be used to wrap any application without referencing the underlying methods. It defines a __call__ method that allows the class instance to be used as an AWS Lambda event handler function. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The handler in the example above could be replaced with a function. def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. return asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response","title":"Creating an AWS Lambda handler"},{"location":"adapter/#retrieving-the-aws-event-and-context","text":"The AWS Lambda handler event and context arguments are made available to an ASGI application in the ASGI connection scope. scope [ 'aws.event' ] scope [ 'aws.context' ] If you're using FastAPI it can be retrieved from the scope attribute of the request object. from fastapi import FastAPI from mangum import Mangum from starlette.requests import Request app = FastAPI () @app . get ( \"/\" ) def hello ( request : Request ): return { \"aws_event\" : request . scope [ \"aws.event\" ]} handler = Mangum ( app )","title":"Retrieving the AWS event and context"},{"location":"asgi-frameworks/","text":"Frameworks Mangum is intended to provide support to any ASGI ( Asynchronous Server Gateway Interface ) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :) Background We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... Limitations An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, such as how Mangum implements WebSocket backends to persist connection details across instances, but these kinds of limitations should generally be dealt with outside of Mangum itself. Frameworks The examples on this page attempt to demonstrate the most basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account. Starlette Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests and as an application framework in the example project. It is developed by Encode , a wonderful community and collection of projects that is building the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app ) FastAPI FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) Responder Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks? Quart Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app ) Sanic Sanic is a Python 3.6+ web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app ) Django Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , lifespan = \"off\" ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same. Channels Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , lifespan = \"off\" )","title":"ASGI Frameworks"},{"location":"asgi-frameworks/#frameworks","text":"Mangum is intended to provide support to any ASGI ( Asynchronous Server Gateway Interface ) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :)","title":"Frameworks"},{"location":"asgi-frameworks/#background","text":"We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ...","title":"Background"},{"location":"asgi-frameworks/#limitations","text":"An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, such as how Mangum implements WebSocket backends to persist connection details across instances, but these kinds of limitations should generally be dealt with outside of Mangum itself.","title":"Limitations"},{"location":"asgi-frameworks/#frameworks_1","text":"The examples on this page attempt to demonstrate the most basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account.","title":"Frameworks"},{"location":"asgi-frameworks/#starlette","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests and as an application framework in the example project. It is developed by Encode , a wonderful community and collection of projects that is building the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app )","title":"Starlette"},{"location":"asgi-frameworks/#fastapi","text":"FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app )","title":"FastAPI"},{"location":"asgi-frameworks/#responder","text":"Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks?","title":"Responder"},{"location":"asgi-frameworks/#quart","text":"Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app )","title":"Quart"},{"location":"asgi-frameworks/#sanic","text":"Sanic is a Python 3.6+ web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app )","title":"Sanic"},{"location":"asgi-frameworks/#django","text":"Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , lifespan = \"off\" ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same.","title":"Django"},{"location":"asgi-frameworks/#channels","text":"Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , lifespan = \"off\" )","title":"Channels"},{"location":"external-links/","text":"External Links TODO.","title":"External Links"},{"location":"external-links/#external-links","text":"TODO.","title":"External Links"},{"location":"http/","text":"HTTP Mangum provides support for both REST and the newer HTTP APIs in API Gateway. It also includes configurable binary response support. from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware from mangum import Mangum app = FastAPI () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) @app . get ( \"/\" ) async def main (): return \"somebigcontent\" handler = Mangum ( app , TEXT_MIME_TYPES = [ \"application/vnd.some.type\" ]) Configuring binary responses Binary responses are determined using the Content-Type and Content-Encoding headers from the event request and a list of text MIME types. Text MIME types By default, all response data will be base64 encoded and include isBase64Encoded=True in the response except the default text MIME types and any MIME types included in the TEXT_MIME_TYPES list setting. The following types are excluded from binary responses by default: application/json application/javascript application/xml application/vnd.api+json Additionally, any Content-Type header prefixed with text/ is automatically excluded. GZip If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of MIME type. API The HTTPCycle is used by the adapter to communicate message events between the application and AWS. It is a state machine that handles the entire ASGI request and response cycle. HTTPCycle class mangum.protocols.http. HTTPCycle ( scope , body , text_mime_types , state= , response= ) Manages the application cycle for an ASGI http connection. scope - A dictionary containing the connection scope used to run the ASGI application instance. body - A byte string containing the body content of the request. text_mime_types - A list of mime types of MIME types that should not return a binary response in API Gateway. state - An enumerated HTTPCycleState type that indicates the state of the ASGI connection. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. response - A dictionary containing the response data to return in AWS Lambda. run ( self , app ) Calls the application with the http connection scope. receive ( self ) Awaited by the application to receive ASGI http events. send ( self , message ) Awaited by the application to send ASGI http events. HTTPCycleState class mangum.protocols.http. HTTPCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI http connection. REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the http type. RESPONSE - The http.response.start event has been sent by the application. The next expected message is the http.response.body event, containing the body content. An application may pass the more_body argument to send content in chunks, however content will always be returned in a single response, never streamed. COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.","title":"HTTP"},{"location":"http/#http","text":"Mangum provides support for both REST and the newer HTTP APIs in API Gateway. It also includes configurable binary response support. from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware from mangum import Mangum app = FastAPI () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) @app . get ( \"/\" ) async def main (): return \"somebigcontent\" handler = Mangum ( app , TEXT_MIME_TYPES = [ \"application/vnd.some.type\" ])","title":"HTTP"},{"location":"http/#configuring-binary-responses","text":"Binary responses are determined using the Content-Type and Content-Encoding headers from the event request and a list of text MIME types.","title":"Configuring binary responses"},{"location":"http/#text-mime-types","text":"By default, all response data will be base64 encoded and include isBase64Encoded=True in the response except the default text MIME types and any MIME types included in the TEXT_MIME_TYPES list setting. The following types are excluded from binary responses by default: application/json application/javascript application/xml application/vnd.api+json Additionally, any Content-Type header prefixed with text/ is automatically excluded.","title":"Text MIME types"},{"location":"http/#gzip","text":"If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of MIME type.","title":"GZip"},{"location":"http/#api","text":"The HTTPCycle is used by the adapter to communicate message events between the application and AWS. It is a state machine that handles the entire ASGI request and response cycle.","title":"API"},{"location":"http/#httpcycle","text":"class mangum.protocols.http. HTTPCycle ( scope , body , text_mime_types , state= , response= ) Manages the application cycle for an ASGI http connection. scope - A dictionary containing the connection scope used to run the ASGI application instance. body - A byte string containing the body content of the request. text_mime_types - A list of mime types of MIME types that should not return a binary response in API Gateway. state - An enumerated HTTPCycleState type that indicates the state of the ASGI connection. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. response - A dictionary containing the response data to return in AWS Lambda. run ( self , app ) Calls the application with the http connection scope. receive ( self ) Awaited by the application to receive ASGI http events. send ( self , message ) Awaited by the application to send ASGI http events.","title":"HTTPCycle"},{"location":"http/#httpcyclestate","text":"class mangum.protocols.http. HTTPCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI http connection. REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the http type. RESPONSE - The http.response.start event has been sent by the application. The next expected message is the http.response.body event, containing the body content. An application may pass the more_body argument to send content in chunks, however content will always be returned in a single response, never streamed. COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.","title":"HTTPCycleState"},{"location":"lifespan/","text":"Lifespan Mangum supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): pass @app . on_event ( \"shutdown\" ) async def shutdown_event (): pass @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } handler = Mangum ( app , lifespan = \"auto\" ) Configuring Lifespan events Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are auto , on , and off . Options auto Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a lifespan.startup.failed event is sent. on Application support for lifespan is explicit . Any error that occurs during startup will be raised and a 500 response will be returned. off Application support for lifespan is ignored . The application will not enter the lifespan cycle context. Defaults to auto . API The LifespanCycle is a state machine that handles ASGI lifespan events intended to run before and after HTTP and WebSocket requests are handled. LifespanCycle class mangum.protocols.lifespan. LifespanCycle ( app , lifespan , state= , exception=None ) Manages the application cycle for an ASGI lifespan connection. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . state - An enumerated LifespanCycleState type that indicates the state of the ASGI connection. exception - An exception raised while handling the ASGI event. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. startup_event - An asyncio event object used to control the application startup flow. shutdown_event - An asyncio event object used to control the application shutdown flow. exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state. run ( self ) Calls the application with the lifespan connection scope. receive ( self ) Awaited by the application to receive ASGI lifespan events. send ( self , message ) Awaited by the application to send ASGI lifespan events. startup ( self ) Pushes the lifespan startup event to application queue and handles errors. shutdown ( self ) Pushes the lifespan shutdown event to application queue and handles errors. Context manager Unlike the HTTPCycle and WebSocketCycle classes, the LifespanCycle is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context. with ExitStack () as stack : # Ignore lifespan events entirely if the `lifespan` setting is `off`. if self . lifespan in ( \"auto\" , \"on\" ): asgi_cycle : typing . ContextManager = LifespanCycle ( self . app , self . lifespan ) stack . enter_context ( asgi_cycle ) The magic methods __enter__ and __exit__ handle running the async tasks that perform startup and shutdown functions. def __enter__ ( self ) -> None : \"\"\" Runs the event loop for application startup. \"\"\" self . loop . create_task ( self . run ()) self . loop . run_until_complete ( self . startup ()) def __exit__ ( self , exc_type : typing . Optional [ typing . Type [ BaseException ]], exc_value : typing . Optional [ BaseException ], traceback : typing . Optional [ types . TracebackType ], ) -> None : \"\"\" Runs the event loop for application shutdown. \"\"\" self . loop . run_until_complete ( self . shutdown ()) LifespanCycleState class mangum.protocols.lifespan. LifespanCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI lifespan connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the lifespan type. STARTUP - The lifespan startup event has been pushed to the queue to be received by the application. SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application. FAILED - A lifespan failure has been detected, and the connection will be closed with an error. UNSUPPORTED - An application attempted to send a message before receiving the lifepan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.","title":"Lifespan"},{"location":"lifespan/#lifespan","text":"Mangum supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): pass @app . on_event ( \"shutdown\" ) async def shutdown_event (): pass @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } handler = Mangum ( app , lifespan = \"auto\" )","title":"Lifespan"},{"location":"lifespan/#configuring-lifespan-events","text":"Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are auto , on , and off .","title":"Configuring Lifespan events"},{"location":"lifespan/#options","text":"auto Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a lifespan.startup.failed event is sent. on Application support for lifespan is explicit . Any error that occurs during startup will be raised and a 500 response will be returned. off Application support for lifespan is ignored . The application will not enter the lifespan cycle context. Defaults to auto .","title":"Options"},{"location":"lifespan/#api","text":"The LifespanCycle is a state machine that handles ASGI lifespan events intended to run before and after HTTP and WebSocket requests are handled.","title":"API"},{"location":"lifespan/#lifespancycle","text":"class mangum.protocols.lifespan. LifespanCycle ( app , lifespan , state= , exception=None ) Manages the application cycle for an ASGI lifespan connection. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . state - An enumerated LifespanCycleState type that indicates the state of the ASGI connection. exception - An exception raised while handling the ASGI event. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. startup_event - An asyncio event object used to control the application startup flow. shutdown_event - An asyncio event object used to control the application shutdown flow. exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state. run ( self ) Calls the application with the lifespan connection scope. receive ( self ) Awaited by the application to receive ASGI lifespan events. send ( self , message ) Awaited by the application to send ASGI lifespan events. startup ( self ) Pushes the lifespan startup event to application queue and handles errors. shutdown ( self ) Pushes the lifespan shutdown event to application queue and handles errors.","title":"LifespanCycle"},{"location":"lifespan/#context-manager","text":"Unlike the HTTPCycle and WebSocketCycle classes, the LifespanCycle is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context. with ExitStack () as stack : # Ignore lifespan events entirely if the `lifespan` setting is `off`. if self . lifespan in ( \"auto\" , \"on\" ): asgi_cycle : typing . ContextManager = LifespanCycle ( self . app , self . lifespan ) stack . enter_context ( asgi_cycle ) The magic methods __enter__ and __exit__ handle running the async tasks that perform startup and shutdown functions. def __enter__ ( self ) -> None : \"\"\" Runs the event loop for application startup. \"\"\" self . loop . create_task ( self . run ()) self . loop . run_until_complete ( self . startup ()) def __exit__ ( self , exc_type : typing . Optional [ typing . Type [ BaseException ]], exc_value : typing . Optional [ BaseException ], traceback : typing . Optional [ types . TracebackType ], ) -> None : \"\"\" Runs the event loop for application shutdown. \"\"\" self . loop . run_until_complete ( self . shutdown ())","title":"Context manager"},{"location":"lifespan/#lifespancyclestate","text":"class mangum.protocols.lifespan. LifespanCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI lifespan connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the lifespan type. STARTUP - The lifespan startup event has been pushed to the queue to be received by the application. SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application. FAILED - A lifespan failure has been detected, and the connection will be closed with an error. UNSUPPORTED - An application attempted to send a message before receiving the lifepan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.","title":"LifespanCycleState"},{"location":"release-notes/","text":"Release Notes 0.9.1 Refactor lifespan class to be more consistent with other cycle classes and to be more compliant with ASGI spec Bugfix lifespan startup behaviour, allow lifespan cycle to be used as a context manager in the adapter #107 . Deprecate enable_lifespan parameter to be replaced by new lifespan option Include CHANGELOG in repo and release notes in documentation #110 Update protocol classes generally with docstrings/comments/better state transitions/more compliant with ASGI spec. Overhaul documentation structure and content. 0.9.0 Improve documentation #48 Resolve issue with rawQueryString in HTTP APIs using wrong type #105 Implement new WebSocket storage backends for managing connections (PostgreSQL, Redis, DyanmoDB, S3, SQlite) using a single dsn configuration parameter #100 0.9.0b1 (pre-release) Refactor ASGI lifespan handlers and automatically detect if lifespan is supported by an application #62 Decouple WebSocket support from DyanmoDB to allow alternative WebSocket storage backends #52 Implement new WebSocket storage backends for managing connections (PostgreSQL, Redis, DyanmoDB, S3, SQlite) Improving logging throughout the various classes","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#091","text":"Refactor lifespan class to be more consistent with other cycle classes and to be more compliant with ASGI spec Bugfix lifespan startup behaviour, allow lifespan cycle to be used as a context manager in the adapter #107 . Deprecate enable_lifespan parameter to be replaced by new lifespan option Include CHANGELOG in repo and release notes in documentation #110 Update protocol classes generally with docstrings/comments/better state transitions/more compliant with ASGI spec. Overhaul documentation structure and content.","title":"0.9.1"},{"location":"release-notes/#090","text":"Improve documentation #48 Resolve issue with rawQueryString in HTTP APIs using wrong type #105 Implement new WebSocket storage backends for managing connections (PostgreSQL, Redis, DyanmoDB, S3, SQlite) using a single dsn configuration parameter #100","title":"0.9.0"},{"location":"release-notes/#090b1-pre-release","text":"Refactor ASGI lifespan handlers and automatically detect if lifespan is supported by an application #62 Decouple WebSocket support from DyanmoDB to allow alternative WebSocket storage backends #52 Implement new WebSocket storage backends for managing connections (PostgreSQL, Redis, DyanmoDB, S3, SQlite) Improving logging throughout the various classes","title":"0.9.0b1 (pre-release)"},{"location":"websockets/","text":"WebSockets Mangum provides support for WebSocket API events in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle using a configured storage backend. import os from mangum import Mangum from starlette.templating import Jinja2Templates from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.routing import Route , WebSocketRoute DSN_URL = os . environ [ \"DSN_URL\" ] WEBSOCKET_URL = os . environ [ \"WEBSOCKET_URL\" ] HTML = b \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\" %s \"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" % WEBSOCKET_URL class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: { data } \" ) routes = [ Route ( \"/\" , Homepage ), WebSocketRoute ( \"/ws\" , Echo ) ] app = Starlette ( routes = routes ) handler = Mangum ( app , dsn = DSN_URL ) Configuring a storage backend A data source is required in order to persist the WebSocket client connections stored in API Gateway*. Any data source can be used as long as it is accessible remotely to the AWS Lambda function. All supported backends require a dsn connection string argument to configure the connection between the adapter and the data source. handler = Mangum ( app , dsn = \"[postgresql|redis|dynamodb|s3|sqlite]://[...]\" ) *Read the section on ( handling events in API Gateway for more information.) Supported backends The following backends are currently supported: dynamodb s3 postgresql redis sqlite (for local debugging) Note : The backend storage implementations offer very minimal configuration for creating, fetching, and deleting connection details and will be improved over time. Any error reports or suggestions regarding these backends are greatly appreciated, feel free to open an issue . DynamoDB The DynamoDBBackend uses a DynamoDB table to store the connection details. Usage handler = Mangum ( app , dsn = \"dynamodb://mytable\" ) Parameters The DynamoDB backend dsn uses the following connection string syntax: dynamodb://<table_name>[?region=<region-name>&endpoint_url=<url>] table_name (Required) The name of the table in DynamoDB. region_name The region name of the DyanmoDB table. endpoint_url The endpoint url to use in DynamoDB calls. This is useful if you are debugging locally with a package such as serverless-dynamodb-local . S3 The S3Backend uses an S3 bucket as a key-value store to store the connection details. Usage handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" ) Parameters The S3 backend dsn uses the following connection string syntax: s3://<bucket>[/key/...][?region=<region-name>] bucket (Required) The name of the bucket in S3. region_name The region name of the S3 bucket. PostgreSQL The PostgreSQLBackend requires psycopg2 and access to a remote PostgreSQL database. Usage handler = Mangum ( app , dsn = \"postgresql://myuser:mysecret@my.host:5432/mydb\" ) Parameters The PostgreSQL backend dsn uses the following connection string syntax: postgresql://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] host (Required) The network location of the PostgreSQL database Read more about the supported uri schemes and additional parameters here . Redis The RedisBackend requires redis-py and access to a Redis server. Usage handler = Mangum ( app , dsn = \"redis://:mysecret@my.host:6379/0\" ) Parameters The Redis backend dsn uses the following connection string syntax: redis://[[user:]password@]host[:port][/database] host (Required) The network location of the Redis server. Read more about the supported uri schemes and additional parameters here . SQLite The sqlite backend uses a local sqlite3 database to store connection. It is intended for local debugging (with a package such as Serverless Offline ) and will not work in an AWS Lambda deployment. Usage handler = Mangum ( app , dsn = \"sqlite://mydbfile.sqlite3\" ) Parameters The SQLite backend uses the following connection string syntax: sqlite://[file_path].db file_path (Required) The file name or path to an sqlite3 database file. If one does not exist, then it will be created automatically. API The WebSocketCycle is used by the adapter to communicate message events between the application and WebSocket client connections in API Gateway using a storage backend to persist the connection scope . It is a state machine that handles the ASGI request and response cycle for each individual message sent by a client. WebSocketCycle class mangum.protocols.websockets. WebSocketCycle ( body , websocket , state= , response= ) Manages the application cycle for an ASGI websocket connection. body - A string containing the body content of the request. websocket - A WebSocket connection handler interface for the selected WebSocketBackend subclass. Contains the ASGI connection scope and client connection identifier. state - An enumerated WebSocketCycleState type that indicates the state of the ASGI connection. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. response - A dictionary containing the response data to return in AWS Lambda. This will only contain a statusCode for WebSocket connections. run ( self , app ) Calls the application with the websocket connection scope. receive ( self ) Awaited by the application to receive ASGI websocket events. send ( self , message ) Awaited by the application to send ASGI websocket events. Handling API Gateway events There are three WebSocket events sent by API Gateway for a WebSocket API connection. Each event requires returning a response immediately, and the information required to create the connection scope is only available in the initial CONNECT event. Messages are only sent in MESSAGE events that occur after the initial connection is established, and they do not include the details of the initial connect event. Due to the stateless nature of AWS Lambda, a storage backend is required to persist the WebSocket connection details for the duration of a client connection. CONNECT A persistent connection between the client and a WebSocket API is being initiated. The adapter uses a supported WebSocket backend to store the connection id and initial request information. MESSAGE A connected client has sent a message. The adapter will retrieve the initial request information from the backend using the connection id to form the ASGI connection scope and run the ASGI application cycle. DISCONNECT The client or the server disconnects from the API. The adapter will remove the connection from the backend. WebSocketCycleState class mangum.protocols.websockets. WebSocketCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI WebSocket connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the websocket type. HANDSHAKE - The ASGI websocket connection with the application has been established, and a websocket.connect event has been pushed to the application queue. The application will respond by accepting or rejecting the connection. If rejected, a 403 response will be returned to the client, and it will be removed from API Gateway. RESPONSE - Handshake accepted by the application. Data received in the API Gateway message event will be sent to the application. A websocket.receive event will be pushed to the application queue. DISCONNECTING - The ASGI connection cycle is complete and should be disconnected from the application. A websocket.disconnect event will be pushed to the queue, and a response will be returned to the client connection. CLOSED - The application has sent a websocket.close message. This will either be in response to a websocket.disconnect event or occurs when a connection is rejected in response to a websocket.connect event.","title":"WebSockets"},{"location":"websockets/#websockets","text":"Mangum provides support for WebSocket API events in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle using a configured storage backend. import os from mangum import Mangum from starlette.templating import Jinja2Templates from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.routing import Route , WebSocketRoute DSN_URL = os . environ [ \"DSN_URL\" ] WEBSOCKET_URL = os . environ [ \"WEBSOCKET_URL\" ] HTML = b \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\" %s \"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" % WEBSOCKET_URL class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: { data } \" ) routes = [ Route ( \"/\" , Homepage ), WebSocketRoute ( \"/ws\" , Echo ) ] app = Starlette ( routes = routes ) handler = Mangum ( app , dsn = DSN_URL )","title":"WebSockets"},{"location":"websockets/#configuring-a-storage-backend","text":"A data source is required in order to persist the WebSocket client connections stored in API Gateway*. Any data source can be used as long as it is accessible remotely to the AWS Lambda function. All supported backends require a dsn connection string argument to configure the connection between the adapter and the data source. handler = Mangum ( app , dsn = \"[postgresql|redis|dynamodb|s3|sqlite]://[...]\" ) *Read the section on ( handling events in API Gateway for more information.)","title":"Configuring a storage backend"},{"location":"websockets/#supported-backends","text":"The following backends are currently supported: dynamodb s3 postgresql redis sqlite (for local debugging) Note : The backend storage implementations offer very minimal configuration for creating, fetching, and deleting connection details and will be improved over time. Any error reports or suggestions regarding these backends are greatly appreciated, feel free to open an issue .","title":"Supported backends"},{"location":"websockets/#dynamodb","text":"The DynamoDBBackend uses a DynamoDB table to store the connection details.","title":"DynamoDB"},{"location":"websockets/#usage","text":"handler = Mangum ( app , dsn = \"dynamodb://mytable\" )","title":"Usage"},{"location":"websockets/#parameters","text":"The DynamoDB backend dsn uses the following connection string syntax: dynamodb://<table_name>[?region=<region-name>&endpoint_url=<url>] table_name (Required) The name of the table in DynamoDB. region_name The region name of the DyanmoDB table. endpoint_url The endpoint url to use in DynamoDB calls. This is useful if you are debugging locally with a package such as serverless-dynamodb-local .","title":"Parameters"},{"location":"websockets/#s3","text":"The S3Backend uses an S3 bucket as a key-value store to store the connection details.","title":"S3"},{"location":"websockets/#usage_1","text":"handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"Usage"},{"location":"websockets/#parameters_1","text":"The S3 backend dsn uses the following connection string syntax: s3://<bucket>[/key/...][?region=<region-name>] bucket (Required) The name of the bucket in S3. region_name The region name of the S3 bucket.","title":"Parameters"},{"location":"websockets/#postgresql","text":"The PostgreSQLBackend requires psycopg2 and access to a remote PostgreSQL database.","title":"PostgreSQL"},{"location":"websockets/#usage_2","text":"handler = Mangum ( app , dsn = \"postgresql://myuser:mysecret@my.host:5432/mydb\" )","title":"Usage"},{"location":"websockets/#parameters_2","text":"The PostgreSQL backend dsn uses the following connection string syntax: postgresql://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] host (Required) The network location of the PostgreSQL database Read more about the supported uri schemes and additional parameters here .","title":"Parameters"},{"location":"websockets/#redis","text":"The RedisBackend requires redis-py and access to a Redis server.","title":"Redis"},{"location":"websockets/#usage_3","text":"handler = Mangum ( app , dsn = \"redis://:mysecret@my.host:6379/0\" )","title":"Usage"},{"location":"websockets/#parameters_3","text":"The Redis backend dsn uses the following connection string syntax: redis://[[user:]password@]host[:port][/database] host (Required) The network location of the Redis server. Read more about the supported uri schemes and additional parameters here .","title":"Parameters"},{"location":"websockets/#sqlite","text":"The sqlite backend uses a local sqlite3 database to store connection. It is intended for local debugging (with a package such as Serverless Offline ) and will not work in an AWS Lambda deployment.","title":"SQLite"},{"location":"websockets/#usage_4","text":"handler = Mangum ( app , dsn = \"sqlite://mydbfile.sqlite3\" )","title":"Usage"},{"location":"websockets/#parameters_4","text":"The SQLite backend uses the following connection string syntax: sqlite://[file_path].db file_path (Required) The file name or path to an sqlite3 database file. If one does not exist, then it will be created automatically.","title":"Parameters"},{"location":"websockets/#api","text":"The WebSocketCycle is used by the adapter to communicate message events between the application and WebSocket client connections in API Gateway using a storage backend to persist the connection scope . It is a state machine that handles the ASGI request and response cycle for each individual message sent by a client.","title":"API"},{"location":"websockets/#websocketcycle","text":"class mangum.protocols.websockets. WebSocketCycle ( body , websocket , state= , response= ) Manages the application cycle for an ASGI websocket connection. body - A string containing the body content of the request. websocket - A WebSocket connection handler interface for the selected WebSocketBackend subclass. Contains the ASGI connection scope and client connection identifier. state - An enumerated WebSocketCycleState type that indicates the state of the ASGI connection. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. response - A dictionary containing the response data to return in AWS Lambda. This will only contain a statusCode for WebSocket connections. run ( self , app ) Calls the application with the websocket connection scope. receive ( self ) Awaited by the application to receive ASGI websocket events. send ( self , message ) Awaited by the application to send ASGI websocket events.","title":"WebSocketCycle"},{"location":"websockets/#handling-api-gateway-events","text":"There are three WebSocket events sent by API Gateway for a WebSocket API connection. Each event requires returning a response immediately, and the information required to create the connection scope is only available in the initial CONNECT event. Messages are only sent in MESSAGE events that occur after the initial connection is established, and they do not include the details of the initial connect event. Due to the stateless nature of AWS Lambda, a storage backend is required to persist the WebSocket connection details for the duration of a client connection.","title":"Handling API Gateway events"},{"location":"websockets/#connect","text":"A persistent connection between the client and a WebSocket API is being initiated. The adapter uses a supported WebSocket backend to store the connection id and initial request information.","title":"CONNECT"},{"location":"websockets/#message","text":"A connected client has sent a message. The adapter will retrieve the initial request information from the backend using the connection id to form the ASGI connection scope and run the ASGI application cycle.","title":"MESSAGE"},{"location":"websockets/#disconnect","text":"The client or the server disconnects from the API. The adapter will remove the connection from the backend.","title":"DISCONNECT"},{"location":"websockets/#websocketcyclestate","text":"class mangum.protocols.websockets. WebSocketCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI WebSocket connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the websocket type. HANDSHAKE - The ASGI websocket connection with the application has been established, and a websocket.connect event has been pushed to the application queue. The application will respond by accepting or rejecting the connection. If rejected, a 403 response will be returned to the client, and it will be removed from API Gateway. RESPONSE - Handshake accepted by the application. Data received in the API Gateway message event will be sent to the application. A websocket.receive event will be pushed to the application queue. DISCONNECTING - The ASGI connection cycle is complete and should be disconnected from the application. A websocket.disconnect event will be pushed to the queue, and a response will be returned to the client connection. CLOSED - The application has sent a websocket.close message. This will either be in response to a websocket.disconnect event or occurs when a connection is rejected in response to a websocket.connect event.","title":"WebSocketCycleState"}]}