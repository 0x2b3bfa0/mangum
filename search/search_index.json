{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mangum Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Documentation : https://mangum.io/ Features API Gateway support for HTTP , REST , and WebSocket APIs. Multiple storage backend interfaces for managing WebSocket connections. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events. Requirements Python 3.6+ Installation pip install mangum Note : WebSocket support is currently available only in the master branch. Usage The Mangum adapter class is designed to wrap any ASGI application and returns a callable. It can wrap an application and be assigned as the handler: from mangum import Mangum # Define an ASGI application handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately: def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response Configuration The adapter accepts various arguments for configuring lifespan, logging, HTTP, WebSocket, and API Gateway behaviour. handler = Mangum ( app , enable_lifespan = True , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None ) Parameters app : ASGI application An asynchronous callable that conforms to ASGI specification version 3.0. This will usually be a framework application instance that exposes a valid ASGI callable. enable_lifespan : bool Specify whether or not to enable lifespan support. The adapter will automatically determine if lifespan is supported by the framework unless explicitly disabled. log_level : str Level parameter for the logger. api_gateway_base_path : str Base path to strip from URL when using a custom domain name. text_mime_types : list The list of MIME types (in addition to the defaults) that should not return binary responses in API Gateway. dsn : str Connection string to configure a supported WebSocket backend. api_gateway_endpoint_url : str The endpoint url to use when sending data to WebSocket connections in API Gateway. This is useful if you are debugging locally with a package such as serverless-offline . Defaults to the AWS_REGION value in the AWS Lambda environment. api_gateway_region_name : str The region name of the API Gateway contains the connections created by WebSocket APIs. Defaults to the AWS_REGION value in the AWS Lambda environment. Event and context The AWS Lambda handler has event and context parameters. These are available in the ASGI scope object: scope [ 'aws.event' ] scope [ 'aws.context' ] Examples The examples below are ASGI applications (non-framework) with minimal configurations. You should be able to replace the app in these example with most ASGI framework application instances. Please read the HTTP and WebSocket docs for more detailed configuration information. HTTP from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app ) WebSocket from mangum import Mangum html = b \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\" %s \"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" % os . environ . get ( \"WEBSOCKET_URL\" , \"ws://localhost:3000\" ) async def app ( scope , receive , send ): assert scope [ \"type\" ] in ( \"http\" , \"websocket\" ) if scope [ \"type\" ] == \"http\" : message = await receive () if message [ \"type\" ] == \"http.request\" : await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/html; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : html }) if scope [ \"type\" ] == \"websocket\" : while True : message = await receive () if message [ \"type\" ] == \"websocket.connect\" : await send ({ \"type\" : \"websocket.accept\" }) if message [ \"type\" ] == \"websocket.receive\" : text = f \"Received message: { message [ 'text' ] } \" await send ({ \"type\" : \"websocket.send\" , \"text\" : text }) if message [ \"type\" ] == \"websocket.disconnect\" : await send ({ \"type\" : \"websocket.close\" , \"code\" : 1000 }) handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"Introduction"},{"location":"#mangum","text":"Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Documentation : https://mangum.io/","title":"Mangum"},{"location":"#features","text":"API Gateway support for HTTP , REST , and WebSocket APIs. Multiple storage backend interfaces for managing WebSocket connections. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events.","title":"Features"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"pip install mangum Note : WebSocket support is currently available only in the master branch.","title":"Installation"},{"location":"#usage","text":"The Mangum adapter class is designed to wrap any ASGI application and returns a callable. It can wrap an application and be assigned as the handler: from mangum import Mangum # Define an ASGI application handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately: def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response","title":"Usage"},{"location":"#configuration","text":"The adapter accepts various arguments for configuring lifespan, logging, HTTP, WebSocket, and API Gateway behaviour. handler = Mangum ( app , enable_lifespan = True , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None )","title":"Configuration"},{"location":"#parameters","text":"app : ASGI application An asynchronous callable that conforms to ASGI specification version 3.0. This will usually be a framework application instance that exposes a valid ASGI callable. enable_lifespan : bool Specify whether or not to enable lifespan support. The adapter will automatically determine if lifespan is supported by the framework unless explicitly disabled. log_level : str Level parameter for the logger. api_gateway_base_path : str Base path to strip from URL when using a custom domain name. text_mime_types : list The list of MIME types (in addition to the defaults) that should not return binary responses in API Gateway. dsn : str Connection string to configure a supported WebSocket backend. api_gateway_endpoint_url : str The endpoint url to use when sending data to WebSocket connections in API Gateway. This is useful if you are debugging locally with a package such as serverless-offline . Defaults to the AWS_REGION value in the AWS Lambda environment. api_gateway_region_name : str The region name of the API Gateway contains the connections created by WebSocket APIs. Defaults to the AWS_REGION value in the AWS Lambda environment.","title":"Parameters"},{"location":"#event-and-context","text":"The AWS Lambda handler has event and context parameters. These are available in the ASGI scope object: scope [ 'aws.event' ] scope [ 'aws.context' ]","title":"Event and context"},{"location":"#examples","text":"The examples below are ASGI applications (non-framework) with minimal configurations. You should be able to replace the app in these example with most ASGI framework application instances. Please read the HTTP and WebSocket docs for more detailed configuration information.","title":"Examples"},{"location":"#http","text":"from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app )","title":"HTTP"},{"location":"#websocket","text":"from mangum import Mangum html = b \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\" %s \"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" % os . environ . get ( \"WEBSOCKET_URL\" , \"ws://localhost:3000\" ) async def app ( scope , receive , send ): assert scope [ \"type\" ] in ( \"http\" , \"websocket\" ) if scope [ \"type\" ] == \"http\" : message = await receive () if message [ \"type\" ] == \"http.request\" : await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/html; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : html }) if scope [ \"type\" ] == \"websocket\" : while True : message = await receive () if message [ \"type\" ] == \"websocket.connect\" : await send ({ \"type\" : \"websocket.accept\" }) if message [ \"type\" ] == \"websocket.receive\" : text = f \"Received message: { message [ 'text' ] } \" await send ({ \"type\" : \"websocket.send\" , \"text\" : text }) if message [ \"type\" ] == \"websocket.disconnect\" : await send ({ \"type\" : \"websocket.close\" , \"code\" : 1000 }) handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"WebSocket"},{"location":"asgi/","text":"ASGI Mangum is intended to be a universal ASGI ( Asynchronous Server Gateway Interface ) adapter. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :) Background We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of application details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... Limitations An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, such as how Mangum implements WebSocket backends to persist connection details across instances, but these kinds of limitations should generally be dealt with outside of Mangum itself. Frameworks The examples on this page attempt to demonstrate the most basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account. Starlette Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests and as an application framework in the example project. It is developed by Encode , a wonderful community and collection of projects that is building the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app ) That's it. FastAPI FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) Responder Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks? Quart Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app ) Sanic Sanic is a Python 3.6+ web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app ) Django Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , enable_lifespan = False ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same. Channels Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , enable_lifespan = False ) Middleware In addition to framework compatability, it is possible to wrap applications that are wrapped in ASGI middleware. A case of using middleware comes up in one of Mangum's HTTP API tests. The test uses a generic, non-framework ASGI application, but it relies on Starlette's GZipMiddleware to test the adapter's GZip support: async def app ( scope , receive , send ): assert scope [ \"type\" ] == \"http\" await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"application/json\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello world.\" }) handler = Mangum ( GZipMiddleware ( app )) Lifespan Mangum implements the lifespan ASGI sub-specification to support startup/shutdown events. Lifespan support is automatically determined by the adapter class unless explicitly disabled.","title":"ASGI"},{"location":"asgi/#asgi","text":"Mangum is intended to be a universal ASGI ( Asynchronous Server Gateway Interface ) adapter. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :)","title":"ASGI"},{"location":"asgi/#background","text":"We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of application details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ...","title":"Background"},{"location":"asgi/#limitations","text":"An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, such as how Mangum implements WebSocket backends to persist connection details across instances, but these kinds of limitations should generally be dealt with outside of Mangum itself.","title":"Limitations"},{"location":"asgi/#frameworks","text":"The examples on this page attempt to demonstrate the most basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account.","title":"Frameworks"},{"location":"asgi/#starlette","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests and as an application framework in the example project. It is developed by Encode , a wonderful community and collection of projects that is building the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app ) That's it.","title":"Starlette"},{"location":"asgi/#fastapi","text":"FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app )","title":"FastAPI"},{"location":"asgi/#responder","text":"Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks?","title":"Responder"},{"location":"asgi/#quart","text":"Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app )","title":"Quart"},{"location":"asgi/#sanic","text":"Sanic is a Python 3.6+ web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app )","title":"Sanic"},{"location":"asgi/#django","text":"Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , enable_lifespan = False ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same.","title":"Django"},{"location":"asgi/#channels","text":"Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , enable_lifespan = False )","title":"Channels"},{"location":"asgi/#middleware","text":"In addition to framework compatability, it is possible to wrap applications that are wrapped in ASGI middleware. A case of using middleware comes up in one of Mangum's HTTP API tests. The test uses a generic, non-framework ASGI application, but it relies on Starlette's GZipMiddleware to test the adapter's GZip support: async def app ( scope , receive , send ): assert scope [ \"type\" ] == \"http\" await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"application/json\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello world.\" }) handler = Mangum ( GZipMiddleware ( app ))","title":"Middleware"},{"location":"asgi/#lifespan","text":"Mangum implements the lifespan ASGI sub-specification to support startup/shutdown events. Lifespan support is automatically determined by the adapter class unless explicitly disabled.","title":"Lifespan"},{"location":"http/","text":"HTTP Mangum provides support for HTTP and REST APIs in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle. Usage handler = Mangum ( app ) Binary support Binary response support is available depending on the Content-Type and Content-Encoding headers. The default text mime types are the following: application/json application/javascript application/xml application/vnd.api+json All Content-Type headers starting with text/ are included by default. If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of mime type. Binary response bodies will be base64 encoded and isBase64Encoded will be True .","title":"HTTP"},{"location":"http/#http","text":"Mangum provides support for HTTP and REST APIs in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle.","title":"HTTP"},{"location":"http/#usage","text":"handler = Mangum ( app )","title":"Usage"},{"location":"http/#binary-support","text":"Binary response support is available depending on the Content-Type and Content-Encoding headers. The default text mime types are the following: application/json application/javascript application/xml application/vnd.api+json All Content-Type headers starting with text/ are included by default. If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of mime type. Binary response bodies will be base64 encoded and isBase64Encoded will be True .","title":"Binary support"},{"location":"websockets/","text":"WebSockets Mangum provides support for WebSocket API events in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle using a configured storage backend. Events There are WebSocket events sent by API Gateway for a WebSocket API connection. Each event requires returning a response and the initial scope information is only available in connect event, so a storage backend is required to persist the connection details. CONNECT A persistent connection between the client and a WebSocket API is being initiated. The adapter uses a supported WebSocket backend to store the connection id and initial request information. MESSAGE A connected client has sent a message. The adapter will retrieve the initial request information from the backend using the connection id to form the ASGI connection scope and run the ASGI application cycle. DISCONNECT The client or the server disconnects from the API. The adapter will remove the connection from the backend. Backends A data source, such as a cloud database, is required in order to persist the connection identifiers in a 'serverless' environment. Any data source can be used as long as it is accessible remotely to the AWS Lambda function. All supported backends require a dsn connection string argument to configure the connection. Backends that already support connection strings, such as PostgreSQL and Redis, can use their existing syntax. Other backends, such as S3 and DynamoDB, are parsed with a custom syntax defined in the backend class. handler = Mangum ( app , dsn = \"[postgresql|redis|dynamodb|s3|sqlite]://[...]\" ) The following backends are currently supported: dynamodb s3 postgresql redis sqlite (for local debugging) DynamoDB The DynamoDBBackend uses a DynamoDB table to store the connection details. Usage handler = Mangum ( app , dsn = \"dynamodb://mytable\" ) Parameters The DynamoDB backend dsn uses the following connection string syntax: dynamodb://<table_name>[?region=<region-name>&endpoint_url=<url>] table_name (Required) The name of the table in DynamoDB. region_name The region name of the DyanmoDB table. endpoint_url The endpoint url to use in DynamoDB calls. This is useful if you are debugging locally with a package such as serverless-dynamodb-local . S3 The S3Backend uses an S3 bucket as a key-value store to store the connection details. Usage handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" ) Parameters The S3 backend dsn uses the following connection string syntax: s3://<bucket>[/key/...][?region=<region-name>] bucket (Required) The name of the bucket in S3. region_name The region name of the S3 bucket. PostgreSQL The PostgreSQLBackend requires psycopg2 and access to a remote PostgreSQL database. Usage handler = Mangum ( app , dsn = \"postgresql://myuser:mysecret@my.host:5432/mydb\" ) Parameters The PostgreSQL backend dsn uses the following connection string syntax: postgresql://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] host (Required) The network location of the PostgreSQL database Read more about the supported uri schemes and additional parameters here . Redis The RedisBackend requires redis-py and access to a Redis server. Usage handler = Mangum ( app , dsn = \"redis://:mysecret@my.host:6379/0\" ) Parameters The Redis backend dsn uses the following connection string syntax: redis://[[user:]password@]host[:port][/database] host (Required) The network location of the Redis server. Read more about the supported uri schemes and additional parameters here . SQLite The sqlite backend uses a local sqlite3 database to store connection. It is intended for local debugging (with a package such as Serverless Offline ) and will not work in an AWS Lambda deployment. Usage handler = Mangum ( app , dsn = \"sqlite://mydbfile.sqlite3\" ) Parameters The SQLite backend uses the following connection string syntax: sqlite://[file_path].db file_path (Required) The file name or path to an sqlite3 database file. If one does not exist, then it will be created automatically. Alternative backends If you'd like to see a specific data source supported as a backend, please open an issue .","title":"WebSockets"},{"location":"websockets/#websockets","text":"Mangum provides support for WebSocket API events in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle using a configured storage backend.","title":"WebSockets"},{"location":"websockets/#events","text":"There are WebSocket events sent by API Gateway for a WebSocket API connection. Each event requires returning a response and the initial scope information is only available in connect event, so a storage backend is required to persist the connection details.","title":"Events"},{"location":"websockets/#connect","text":"A persistent connection between the client and a WebSocket API is being initiated. The adapter uses a supported WebSocket backend to store the connection id and initial request information.","title":"CONNECT"},{"location":"websockets/#message","text":"A connected client has sent a message. The adapter will retrieve the initial request information from the backend using the connection id to form the ASGI connection scope and run the ASGI application cycle.","title":"MESSAGE"},{"location":"websockets/#disconnect","text":"The client or the server disconnects from the API. The adapter will remove the connection from the backend.","title":"DISCONNECT"},{"location":"websockets/#backends","text":"A data source, such as a cloud database, is required in order to persist the connection identifiers in a 'serverless' environment. Any data source can be used as long as it is accessible remotely to the AWS Lambda function. All supported backends require a dsn connection string argument to configure the connection. Backends that already support connection strings, such as PostgreSQL and Redis, can use their existing syntax. Other backends, such as S3 and DynamoDB, are parsed with a custom syntax defined in the backend class. handler = Mangum ( app , dsn = \"[postgresql|redis|dynamodb|s3|sqlite]://[...]\" ) The following backends are currently supported: dynamodb s3 postgresql redis sqlite (for local debugging)","title":"Backends"},{"location":"websockets/#dynamodb","text":"The DynamoDBBackend uses a DynamoDB table to store the connection details.","title":"DynamoDB"},{"location":"websockets/#usage","text":"handler = Mangum ( app , dsn = \"dynamodb://mytable\" )","title":"Usage"},{"location":"websockets/#parameters","text":"The DynamoDB backend dsn uses the following connection string syntax: dynamodb://<table_name>[?region=<region-name>&endpoint_url=<url>] table_name (Required) The name of the table in DynamoDB. region_name The region name of the DyanmoDB table. endpoint_url The endpoint url to use in DynamoDB calls. This is useful if you are debugging locally with a package such as serverless-dynamodb-local .","title":"Parameters"},{"location":"websockets/#s3","text":"The S3Backend uses an S3 bucket as a key-value store to store the connection details.","title":"S3"},{"location":"websockets/#usage_1","text":"handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"Usage"},{"location":"websockets/#parameters_1","text":"The S3 backend dsn uses the following connection string syntax: s3://<bucket>[/key/...][?region=<region-name>] bucket (Required) The name of the bucket in S3. region_name The region name of the S3 bucket.","title":"Parameters"},{"location":"websockets/#postgresql","text":"The PostgreSQLBackend requires psycopg2 and access to a remote PostgreSQL database.","title":"PostgreSQL"},{"location":"websockets/#usage_2","text":"handler = Mangum ( app , dsn = \"postgresql://myuser:mysecret@my.host:5432/mydb\" )","title":"Usage"},{"location":"websockets/#parameters_2","text":"The PostgreSQL backend dsn uses the following connection string syntax: postgresql://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] host (Required) The network location of the PostgreSQL database Read more about the supported uri schemes and additional parameters here .","title":"Parameters"},{"location":"websockets/#redis","text":"The RedisBackend requires redis-py and access to a Redis server.","title":"Redis"},{"location":"websockets/#usage_3","text":"handler = Mangum ( app , dsn = \"redis://:mysecret@my.host:6379/0\" )","title":"Usage"},{"location":"websockets/#parameters_3","text":"The Redis backend dsn uses the following connection string syntax: redis://[[user:]password@]host[:port][/database] host (Required) The network location of the Redis server. Read more about the supported uri schemes and additional parameters here .","title":"Parameters"},{"location":"websockets/#sqlite","text":"The sqlite backend uses a local sqlite3 database to store connection. It is intended for local debugging (with a package such as Serverless Offline ) and will not work in an AWS Lambda deployment.","title":"SQLite"},{"location":"websockets/#usage_4","text":"handler = Mangum ( app , dsn = \"sqlite://mydbfile.sqlite3\" )","title":"Usage"},{"location":"websockets/#parameters_4","text":"The SQLite backend uses the following connection string syntax: sqlite://[file_path].db file_path (Required) The file name or path to an sqlite3 database file. If one does not exist, then it will be created automatically.","title":"Parameters"},{"location":"websockets/#alternative-backends","text":"If you'd like to see a specific data source supported as a backend, please open an issue .","title":"Alternative backends"}]}