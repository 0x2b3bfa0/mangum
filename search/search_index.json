{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mangum Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Documentation : https://erm.github.io/mangum/introduction/ Features API Gateway support for HTTP , REST , and WebSocket APIs. Multiple storage backend interfaces for managing WebSocket connections. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events. Requirements Python 3.6+ Installation pip install mangum Note : WebSocket support is currently available only in the master branch. Usage The Mangum adapter class is designed to wrap any ASGI application and returns a callable. It can wrap an application and be assigned as the handler: from mangum import Mangum # Define an ASGI application handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately: def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response Configuration The adapter accepts various arguments for configuring lifespan, logging, HTTP, WebSocket, and API Gateway behaviour. handler = Mangum ( app , enable_lifespan = True , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None ) Parameters enable_lifespan : bool Specify whether or not to enable lifespan support. The adapter will automatically determine if lifespan is supported by the framework unless explicitly disabled. log_level : str Level parameter for the logger. api_gateway_base_path : str Base path to strip from URL when using a custom domain name. text_mime_types : list The list of MIME types (in addition to the defaults) that should not return binary responses in API Gateway. dsn : str Connection string to configure a supported WebSocket backend. api_gateway_endpoint_url : str The endpoint url to use when sending data to WebSocket connections in API Gateway. This is useful if you are debugging locally with a package such as serverless-offline . api_gateway_region_name : str The region name of the API Gateway that is managing the API connections. Examples The examples below are \"raw\" ASGI applications with minimal configurations. You are more likely than not going to be using a framework, but you should be able to replace the app in these example with most ASGI framework applications. Please read the HTTP and WebSocket docs for more detailed configuration information. HTTP from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app ) WebSocket from mangum import Mangum html = b \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\" %s \"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" % os . environ . get ( \"WEBSOCKET_URL\" , \"ws://localhost:3000\" ) async def app ( scope , receive , send ): assert scope [ \"type\" ] in ( \"http\" , \"websocket\" ) if scope [ \"type\" ] == \"http\" : message = await receive () if message [ \"type\" ] == \"http.request\" : await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/html; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : html }) if scope [ \"type\" ] == \"websocket\" : while True : message = await receive () if message [ \"type\" ] == \"websocket.connect\" : await send ({ \"type\" : \"websocket.accept\" }) if message [ \"type\" ] == \"websocket.receive\" : text = f \"Received message: { message [ 'text' ] } \" await send ({ \"type\" : \"websocket.send\" , \"text\" : text }) if message [ \"type\" ] == \"websocket.disconnect\" : await send ({ \"type\" : \"websocket.close\" , \"code\" : 1000 }) handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"Introduction"},{"location":"#mangum","text":"Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Documentation : https://erm.github.io/mangum/introduction/","title":"Mangum"},{"location":"#features","text":"API Gateway support for HTTP , REST , and WebSocket APIs. Multiple storage backend interfaces for managing WebSocket connections. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events.","title":"Features"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"pip install mangum Note : WebSocket support is currently available only in the master branch.","title":"Installation"},{"location":"#usage","text":"The Mangum adapter class is designed to wrap any ASGI application and returns a callable. It can wrap an application and be assigned as the handler: from mangum import Mangum # Define an ASGI application handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately: def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response","title":"Usage"},{"location":"#configuration","text":"The adapter accepts various arguments for configuring lifespan, logging, HTTP, WebSocket, and API Gateway behaviour. handler = Mangum ( app , enable_lifespan = True , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None )","title":"Configuration"},{"location":"#parameters","text":"enable_lifespan : bool Specify whether or not to enable lifespan support. The adapter will automatically determine if lifespan is supported by the framework unless explicitly disabled. log_level : str Level parameter for the logger. api_gateway_base_path : str Base path to strip from URL when using a custom domain name. text_mime_types : list The list of MIME types (in addition to the defaults) that should not return binary responses in API Gateway. dsn : str Connection string to configure a supported WebSocket backend. api_gateway_endpoint_url : str The endpoint url to use when sending data to WebSocket connections in API Gateway. This is useful if you are debugging locally with a package such as serverless-offline . api_gateway_region_name : str The region name of the API Gateway that is managing the API connections.","title":"Parameters"},{"location":"#examples","text":"The examples below are \"raw\" ASGI applications with minimal configurations. You are more likely than not going to be using a framework, but you should be able to replace the app in these example with most ASGI framework applications. Please read the HTTP and WebSocket docs for more detailed configuration information.","title":"Examples"},{"location":"#http","text":"from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app )","title":"HTTP"},{"location":"#websocket","text":"from mangum import Mangum html = b \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\" %s \"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" % os . environ . get ( \"WEBSOCKET_URL\" , \"ws://localhost:3000\" ) async def app ( scope , receive , send ): assert scope [ \"type\" ] in ( \"http\" , \"websocket\" ) if scope [ \"type\" ] == \"http\" : message = await receive () if message [ \"type\" ] == \"http.request\" : await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/html; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : html }) if scope [ \"type\" ] == \"websocket\" : while True : message = await receive () if message [ \"type\" ] == \"websocket.connect\" : await send ({ \"type\" : \"websocket.accept\" }) if message [ \"type\" ] == \"websocket.receive\" : text = f \"Received message: { message [ 'text' ] } \" await send ({ \"type\" : \"websocket.send\" , \"text\" : text }) if message [ \"type\" ] == \"websocket.disconnect\" : await send ({ \"type\" : \"websocket.close\" , \"code\" : 1000 }) handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"WebSocket"},{"location":"http/","text":"HTTP Mangum provides support for HTTP and REST APIs in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle. Usage handler = Mangum ( app ) Binary support Binary response support is available depending on the Content-Type and Content-Encoding headers. The default text mime types are the following: application/json application/javascript application/xml application/vnd.api+json All Content-Type headers starting with text/ are included by default. If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of mime type. Binary response bodies will be base64 encoded and isBase64Encoded will be True .","title":"HTTP"},{"location":"http/#http","text":"Mangum provides support for HTTP and REST APIs in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle.","title":"HTTP"},{"location":"http/#usage","text":"handler = Mangum ( app )","title":"Usage"},{"location":"http/#binary-support","text":"Binary response support is available depending on the Content-Type and Content-Encoding headers. The default text mime types are the following: application/json application/javascript application/xml application/vnd.api+json All Content-Type headers starting with text/ are included by default. If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of mime type. Binary response bodies will be base64 encoded and isBase64Encoded will be True .","title":"Binary support"},{"location":"websockets/","text":"WebSockets Mangum provides support for WebSocket API events in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle using a configured storage backend. Events There are WebSocket events sent by API Gateway for a WebSocket API connection. Each event requires returning a response and the initial scope information is only available in connect event, so a storage backend is required to persist the connection details. CONNECT A persistent connection between the client and a WebSocket API is being initiated. The adapter uses a supported WebSocket backend to store the connection id and initial request information. MESSAGE A connected client has sent a message. The adapter will retrieve the initial request information from the backend using the connection id to form the ASGI connection scope and run the ASGI application cycle. DISCONNECT The client or the server disconnects from the API. The adapter will remove the connection from the backend. Backends A data source, such as a cloud database, is required in order to persist the connection identifiers in a 'serverless' environment. Any data source can be used as long as it is accessible remotely to the AWS Lambda function. All supported backends require a dsn connection string argument to configure the connection. Backends that already support connection strings, such as PostgreSQL and Redis, can use their existing syntax. Other backends, such as S3 and DynamoDB, are parsed with a custom syntax defined in the backend class. handler = Mangum ( app , dsn = \"[postgresql|redis|dynamodb|s3|sqlite]://[...]\" ) The following backends are currently supported: dynamodb s3 postgresql redis sqlite (for local debugging) DynamoDB The DynamoDBBackend uses a DynamoDB table to store the connection details. Usage handler = Mangum ( app , dsn = \"dynamodb://mytable\" ) Parameters The DynamoDB backend dsn uses the following connection string syntax: dynamodb://<table_name>[?region=<region-name>&endpoint_url=<url>] table_name (Required) The name of the table in DynamoDB. region_name The region name of the DyanmoDB table. endpoint_url The endpoint url to use in DynamoDB calls. This is useful if you are debugging locally with a package such as serverless-dynamodb-local . S3 The S3Backend uses an S3 bucket as a key-value store to store the connection details. Usage handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" ) Parameters The S3 backend dsn uses the following connection string syntax: s3://<bucket>[/key/...][?region=<region-name>] bucket (Required) The name of the bucket in S3. region_name The region name of the S3 bucket. PostgreSQL The PostgreSQLBackend requires psycopg2 and access to a remote PostgreSQL database. Usage handler = Mangum ( app , dsn = \"postgresql://myuser:mysecret@my.host:5432/mydb\" ) Parameters The PostgreSQL backend dsn uses the following connection string syntax: postgresql://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] host (Required) The network location of the PostgreSQL database Read more about the supported uri schemes and additional parameters here . Redis The RedisBackend requires redis-py and access to a Redis server. Usage handler = Mangum ( app , dsn = \"redis://:mysecret@my.host:6379/0\" ) Parameters The Redis backend dsn uses the following connection string syntax: redis://[[user:]password@]host[:port][/database] host (Required) The network location of the Redis server. Read more about the supported uri schemes and additional parameters here . SQLite The sqlite backend uses a local sqlite3 database to store connection. It is intended for local debugging (with a package such as Serverless Offline ) and will not work in an AWS Lambda deployment. Usage handler = Mangum ( app , dsn = \"sqlite://mydbfile.sqlite3\" ) Parameters The SQLite backend uses the following connection string syntax: sqlite://[file_path].db file_path (Required) The file name or path to an sqlite3 database file. If one does not exist, then it will be created automatically. Alternative backends If you'd like to see a specific data source supported as a backend, please open an issue .","title":"WebSockets"},{"location":"websockets/#websockets","text":"Mangum provides support for WebSocket API events in API Gateway. The adapter class handles parsing the incoming requests and managing the ASGI cycle using a configured storage backend.","title":"WebSockets"},{"location":"websockets/#events","text":"There are WebSocket events sent by API Gateway for a WebSocket API connection. Each event requires returning a response and the initial scope information is only available in connect event, so a storage backend is required to persist the connection details.","title":"Events"},{"location":"websockets/#connect","text":"A persistent connection between the client and a WebSocket API is being initiated. The adapter uses a supported WebSocket backend to store the connection id and initial request information.","title":"CONNECT"},{"location":"websockets/#message","text":"A connected client has sent a message. The adapter will retrieve the initial request information from the backend using the connection id to form the ASGI connection scope and run the ASGI application cycle.","title":"MESSAGE"},{"location":"websockets/#disconnect","text":"The client or the server disconnects from the API. The adapter will remove the connection from the backend.","title":"DISCONNECT"},{"location":"websockets/#backends","text":"A data source, such as a cloud database, is required in order to persist the connection identifiers in a 'serverless' environment. Any data source can be used as long as it is accessible remotely to the AWS Lambda function. All supported backends require a dsn connection string argument to configure the connection. Backends that already support connection strings, such as PostgreSQL and Redis, can use their existing syntax. Other backends, such as S3 and DynamoDB, are parsed with a custom syntax defined in the backend class. handler = Mangum ( app , dsn = \"[postgresql|redis|dynamodb|s3|sqlite]://[...]\" ) The following backends are currently supported: dynamodb s3 postgresql redis sqlite (for local debugging)","title":"Backends"},{"location":"websockets/#dynamodb","text":"The DynamoDBBackend uses a DynamoDB table to store the connection details.","title":"DynamoDB"},{"location":"websockets/#usage","text":"handler = Mangum ( app , dsn = \"dynamodb://mytable\" )","title":"Usage"},{"location":"websockets/#parameters","text":"The DynamoDB backend dsn uses the following connection string syntax: dynamodb://<table_name>[?region=<region-name>&endpoint_url=<url>] table_name (Required) The name of the table in DynamoDB. region_name The region name of the DyanmoDB table. endpoint_url The endpoint url to use in DynamoDB calls. This is useful if you are debugging locally with a package such as serverless-dynamodb-local .","title":"Parameters"},{"location":"websockets/#s3","text":"The S3Backend uses an S3 bucket as a key-value store to store the connection details.","title":"S3"},{"location":"websockets/#usage_1","text":"handler = Mangum ( app , dsn = \"s3://my-bucket-12345\" )","title":"Usage"},{"location":"websockets/#parameters_1","text":"The S3 backend dsn uses the following connection string syntax: s3://<bucket>[/key/...][?region=<region-name>] bucket (Required) The name of the bucket in S3. region_name The region name of the S3 bucket.","title":"Parameters"},{"location":"websockets/#postgresql","text":"The PostgreSQLBackend requires psycopg2 and access to a remote PostgreSQL database.","title":"PostgreSQL"},{"location":"websockets/#usage_2","text":"handler = Mangum ( app , dsn = \"postgresql://myuser:mysecret@my.host:5432/mydb\" )","title":"Usage"},{"location":"websockets/#parameters_2","text":"The PostgreSQL backend dsn uses the following connection string syntax: postgresql://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] host (Required) The network location of the PostgreSQL database Read more about the supported uri schemes and additional parameters here .","title":"Parameters"},{"location":"websockets/#redis","text":"The RedisBackend requires redis-py and access to a Redis server.","title":"Redis"},{"location":"websockets/#usage_3","text":"handler = Mangum ( app , dsn = \"redis://:mysecret@my.host:6379/0\" )","title":"Usage"},{"location":"websockets/#parameters_3","text":"The Redis backend dsn uses the following connection string syntax: redis://[[user:]password@]host[:port][/database] host (Required) The network location of the Redis server. Read more about the supported uri schemes and additional parameters here .","title":"Parameters"},{"location":"websockets/#sqlite","text":"The sqlite backend uses a local sqlite3 database to store connection. It is intended for local debugging (with a package such as Serverless Offline ) and will not work in an AWS Lambda deployment.","title":"SQLite"},{"location":"websockets/#usage_4","text":"handler = Mangum ( app , dsn = \"sqlite://mydbfile.sqlite3\" )","title":"Usage"},{"location":"websockets/#parameters_4","text":"The SQLite backend uses the following connection string syntax: sqlite://[file_path].db file_path (Required) The file name or path to an sqlite3 database file. If one does not exist, then it will be created automatically.","title":"Parameters"},{"location":"websockets/#alternative-backends","text":"If you'd like to see a specific data source supported as a backend, please open an issue .","title":"Alternative backends"}]}